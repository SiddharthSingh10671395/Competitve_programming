const ll N=1000005;

const ll MOD=1000000007;
ll fact[N], invfact[N];

ll pow(ll a, ll b)
    {
      ll ans=1;
        while(b)
        {
            if(b&1)
                ans=(ans*a)%MOD;
            b/=2;
            a=(a*a)%MOD;
        }
        return ans;
    }

    ll modinv(ll k)
    {
        return pow(k, MOD-2, MOD);
    }

    void precompute()
    {
        fact[0]=fact[1]=1;
        for(ll i=2;i<N;i++)
        {
            fact[i]=fact[i-1]*i;
            fact[i]%=MOD;
        }
        invfact[N-1]=modinv(fact[N-1]);
        for(ll i=N-2;i>=0;i--)
        {
            invfact[i]=invfact[i+1]*(i+1);
            invfact[i]%=MOD;
        }
    }

    ll nCr(ll x, ll y)
    {
        if(y>x)
            return 0;
        ll num=fact[x];
        num*=invfact[y];
        num%=MOD;
        num*=invfact[x-y];
        num%=MOD;
        return num;
    }


// lucas theorem for ncr with mod  O(r)   abc156 D


ll C(ll n, ll r) {
    if(r > n - r) r = n - r; // because C(n, r) == C(n, n - r)
    ll num=1;
    ll den=1;
    for(int i = 0; i < r; i++) {
        num = (num%mod*(n -i)%mod)%mod;
        den=(den%mod*(i+1)%mod)%mod;
        
        
    }
    ll ans= (num%mod*Power(den,mod-2)%mod)%mod;


    return ans;
}
