const ll N=1000005;

const ll MOD=1000000007;
ll fact[N], invfact[N];

ll Power(ll base , ll e)
{
    if(e == 0) return 1;
    ll ans = base; e--;
    while(e)
	{
        if(e & 1) ans = (ans * base) %MOD;
        base = (base * base) %MOD;
        e >>= 1;
	}
	return ans %MOD;
}


ll gcd(ll a,ll b)
{
if(a==0) return b;
else return gcd(a%b,b);
}

    ll modinv(ll k)
    {
        return Power(k, MOD-2);
    }

    void precompute()
    {
        fact[0]=fact[1]=1;
        for(ll i=2;i<N;i++)
        {
            fact[i]=fact[i-1]*i;
            fact[i]%=MOD;
        }
        invfact[N-1]=modinv(fact[N-1]);
        for(ll i=N-2;i>=0;i--)
        {
            invfact[i]=invfact[i+1]*(i+1);
            invfact[i]%=MOD;
        }
    }

    ll nCr(ll x, ll y)
    {
        if(y>x)
            return 0;
        ll num=fact[x];
        num*=invfact[y];
        num%=MOD;
        num*=invfact[x-y];
        num%=MOD;
        return num;
    }


// lucas theorem for ncr with mod  O(r)   abc156 D


ll C(ll n, ll r) {
    if(r > n - r) r = n - r; // because C(n, r) == C(n, n - r)
    ll num=1;
    ll den=1;
    for(int i = 0; i < r; i++) {
        num = (num%mod*(n -i)%mod)%mod;
        den=(den%mod*(i+1)%mod)%mod;
        
        
    }
    ll ans= (num%mod*Power(den,mod-2)%mod)%mod;


    return ans;
}
